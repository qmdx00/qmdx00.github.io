<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Skyscraper</title><link>https://qmdx00.cn/posts/</link><description>Recent content in Posts on Skyscraper</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 10 Mar 2021 13:26:44 +0800</lastBuildDate><atom:link href="https://qmdx00.cn/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>IPv4 Network</title><link>https://qmdx00.cn/posts/ipv4-network/</link><pubDate>Wed, 10 Mar 2021 13:26:44 +0800</pubDate><guid>https://qmdx00.cn/posts/ipv4-network/</guid><description>IPv4网络分类 子网掩码在线换算
各个类别的范围 分类 前缀码 开始地址 结束地址 对应CIDR修饰 默认子网掩码 A类地址 0 0.0.0.0 127.255.255.255 /8 255.0.0.0 B类地址 10 128.0.0.0 191.255.255.255 /16 255.255.0.0 C类地址 110 192.0.0.0 223.255.255.255 /24 255.255.255.0 D类地址 1110 224.0.0.0 239.255.255.255 /4 未定义 E类地址 1111 240.0.0.0 255.255.255.255 /4 未定义 按位来表示 n 表示该二进制位是网络位
H 表示该二进制位是主机位
X 表示该二进制位无特定作用
A类地址 0. 0.</description></item><item><title>Development Environment Setup</title><link>https://qmdx00.cn/posts/ubuntu-desktop-setup/</link><pubDate>Tue, 09 Mar 2021 12:06:20 +0800</pubDate><guid>https://qmdx00.cn/posts/ubuntu-desktop-setup/</guid><description>由于每次重置系统开发环境时都要重新安装一些工具，故而在此做个记录，方便以后的开发环境配置和工具查找。
系统环境 Ubuntu Desktop 20.04，启动盘制作工具 Ecther
软件工具 AppImageLauncher Clashy Chrome VSCode Goland Clion Navicat 破解步骤 破解工具 Postman DingTalk Flameshot（截图软件） 配置全局快捷键 QQ Music 环境配置 系统拓展，开机自启动配置 sudo apt install gnome-tweak-tool 常用命令行工具 sudo apt install net-tools curl make screenfetch vim tree ~/.bashrc # local proxy config proxy(){ http_proxy=&amp;#34;http://127.0.0.1:1087&amp;#34; https_proxy=&amp;#34;http://127.0.0.1:1087&amp;#34; all_proxy=&amp;#34;socks5://127.0.0.1:1086&amp;#34; echo &amp;#34;HTTP PROXY ON&amp;#34; } noproxy(){ unset http_proxy unset https_proxy unset all_proxy echo &amp;#34;HTTP PROXY OFF&amp;#34; } # golang config export PATH=&amp;#34;$PATH:/usr/local/go/bin&amp;#34; export GOPATH=&amp;#34;$HOME/go&amp;#34; export PATH=&amp;#34;$GOPATH/bin:$PATH&amp;#34; export GOPROXY=goproxy.</description></item><item><title>MySQL Index</title><link>https://qmdx00.cn/posts/sql-notes-index/</link><pubDate>Wed, 03 Mar 2021 11:15:02 +0800</pubDate><guid>https://qmdx00.cn/posts/sql-notes-index/</guid><description>极客时间《MySQL实战45讲》阅读笔记，原文地址
索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。
索引的常见模型 三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。
哈希表 哈希表是一种以键值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。
不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。
有序数组 有序数组在等值查询和范围查询场景中的性能就都非常优秀。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
搜索树 二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。
N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。
InnoDB 的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
如果语句是 SELECT * FROM T WHERE ID=500 ，即主键查询方式，则只需要搜索 ID 这棵 B+ 树。 如果语句是 SELECT * FROM T WHERE k=5 ，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</description></item><item><title>MySQL Transaction</title><link>https://qmdx00.cn/posts/sql-notes-transaction/</link><pubDate>Wed, 03 Mar 2021 10:55:29 +0800</pubDate><guid>https://qmdx00.cn/posts/sql-notes-transaction/</guid><description>极客时间《MySQL实战45讲》阅读笔记，原文地址
事务隔离 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
隔离性与隔离级别 隔离性 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。
隔离级别 SQL 标准的事务隔离级别包括：
读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。 读已提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</description></item><item><title>MySQL Structure</title><link>https://qmdx00.cn/posts/sql-notes-sturcture/</link><pubDate>Wed, 27 Jan 2021 15:21:32 +0800</pubDate><guid>https://qmdx00.cn/posts/sql-notes-sturcture/</guid><description>1. 基础架构 逻辑架构 MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。
连接器 通过 mysql 命令来跟服务端建立连接，在完成经典的 TCP 握手后，连接器就开始认证你的身份。 mysql -h$ip -P$port -u$user -p 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。
这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
查询缓存 连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。
MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。
如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。
但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。
查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。
分析器 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么，做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</description></item><item><title>Hello World</title><link>https://qmdx00.cn/posts/hello-world/</link><pubDate>Thu, 10 Dec 2020 17:38:53 +0800</pubDate><guid>https://qmdx00.cn/posts/hello-world/</guid><description>something for nothing
fmt.Println(&amp;#34;hello world&amp;#34;)</description></item></channel></rss>