<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Wimi Yuan"><meta name=description content="极客时间《MySQL实战45讲》阅读笔记，原文地址
 事务隔离 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
隔离性与隔离级别 隔离性 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。
隔离级别 SQL 标准的事务隔离级别包括：
 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。 读已提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL Transaction"><meta name=twitter:description content="极客时间《MySQL实战45讲》阅读笔记，原文地址
 事务隔离 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
隔离性与隔离级别 隔离性 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。
隔离级别 SQL 标准的事务隔离级别包括：
 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。 读已提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。"><meta property="og:title" content="MySQL Transaction"><meta property="og:description" content="极客时间《MySQL实战45讲》阅读笔记，原文地址
 事务隔离 简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
隔离性与隔离级别 隔离性 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。
隔离级别 SQL 标准的事务隔离级别包括：
 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。 读已提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。"><meta property="og:type" content="article"><meta property="og:url" content="https://qmdx00.cn/posts/sql-notes-transaction/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-03T10:55:29+08:00"><meta property="article:modified_time" content="2021-03-03T10:55:29+08:00"><title>MySQL Transaction · Skyscraper</title><link rel=canonical href=https://qmdx00.cn/posts/sql-notes-transaction/><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8/normalize.min.css><link rel=stylesheet href=/css/coder.min.f01c647a0d25b40da992a37c3376291185eed8a50ced8c26cc2c0bcfe38c97df.css integrity="sha256-8Bxkeg0ltA2pkqN8M3YpEYXu2KUM7YwmzCwLz+OMl98=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js integrity=sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4 crossorigin=anonymous></script><meta name=generator content="Hugo 0.81.0"></head><body class=colorscheme-light onload=twemoji.parse(document.body)><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Skyscraper</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://notes.qmdx00.cn/>Notes</a></li><li class=navigation-item><a class=navigation-link href=/links>Links</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>MySQL Transaction</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-03-03T10:55:29+08:00>March 3, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>One-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i><a href=/categories/notes/>Notes</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/tags/mysql/>MySQL</a></div></div></header><div><blockquote><p>极客时间《MySQL实战45讲》阅读笔记，<a href=https://time.geekbang.org/column/article/68963>原文地址</a></p></blockquote><h2 id=事务隔离>事务隔离</h2><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><h2 id=隔离性与隔离级别>隔离性与隔离级别</h2><h3 id=隔离性>隔离性</h3><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p><h3 id=隔离级别>隔离级别</h3><p>SQL 标准的事务隔离级别包括：</p><ul><li>读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读已提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化（serializable ）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main></body></html>